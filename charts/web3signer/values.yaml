# Default values for web3signer.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  serviceAccount:
    create: true

replicaCount: 3

image:
  registry: "docker.io"
  repository: consensys/web3signer
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

## Database connection string, ex. 'postgresql://username:pass@hostname/dbname'
##
dbKeystoreUrl: ""

## The key for decrypting private keys is generated with stakewise-cli sync-db command
## Use this for plain text decryption key (legacy mode)
##
decryptionKey: ""

## Encrypted decryption key configuration
## When enabled, the decryption key is stored encrypted and decrypted at runtime
## via an init container using AWS KMS or Azure Key Vault.
## The decrypted key is passed in-memory (never persisted to disk).
##
## This provides enhanced security because:
##   1. The secret is encrypted at rest in Kubernetes secrets
##   2. Decryption only happens at pod startup via cloud KMS
##   3. The decrypted value is stored in a memory-backed volume (never on disk)
##   4. If the pod restarts, the init container must run again to decrypt
##
## Prerequisites:
##   For AWS (using IRSA - IAM Roles for Service Accounts):
##     1. Create a KMS key and note the key ID/ARN/alias
##     2. Encrypt your decryption key: aws kms encrypt --key-id <key-id> --plaintext "<your-key>" --output text --query CiphertextBlob
##     3. Create an IAM role with kms:Decrypt permission for the key
##     4. Associate the IAM role with the Kubernetes service account using IRSA
##     5. Set serviceAccount.annotations with: eks.amazonaws.com/role-arn: <role-arn>
##
##   For Azure (using Managed Identity):
##     1. Create a Key Vault and a key within it
##     2. Encrypt your decryption key using the Azure CLI or SDK
##     3. Configure Workload Identity or Pod Identity for your AKS cluster
##     4. Grant the managed identity "Key Vault Crypto User" role on the key
##     5. Configure pod identity annotations as needed for your setup
##
encryptedDecryptionKey:
  ## Enable encrypted decryption key mode
  ## When true, uses the encrypted ciphertext and decrypts at runtime
  ## When false, uses the plain decryptionKey above (legacy behavior)
  enabled: false

  ## The encrypted (base64-encoded ciphertext) decryption key
  ## For AWS KMS: This is the base64-encoded output from `aws kms encrypt`
  ## For Azure: This is the base64-encoded output from key vault encryption
  ciphertext: ""

  ## Provider for decryption: "aws" or "azure"
  provider: "aws"

  ## AWS KMS Configuration (used when provider: "aws")
  aws:
    ## AWS region where the KMS key is located
    region: "us-east-1"
    ## The KMS key ID, alias, or ARN to use for decryption
    ## Examples:
    ##   - Key ID: "1234abcd-12ab-34cd-56ef-1234567890ab"
    ##   - Alias: "alias/my-key"
    ##   - ARN: "arn:aws:kms:us-east-1:123456789012:key/..."
    keyId: ""
    ## Optional: Role ARN to assume for cross-account access
    roleArn: ""

  ## Azure Key Vault Configuration (used when provider: "azure")
  azure:
    ## Azure Key Vault name (the vault URL will be https://<vaultName>.vault.azure.net)
    vaultName: ""
    ## The name of the key in the vault
    keyName: ""
    ## Optional: Specific version of the key (latest if empty)
    keyVersion: ""
    ## The encryption algorithm used (RSA-OAEP, RSA-OAEP-256, etc.)
    algorithm: "RSA-OAEP-256"
    ## Optional: Managed Identity Client ID (required when multiple identities exist on the pod)
    clientId: ""

  ## Images for the decryption init container (selected automatically based on provider)
  awsImage:
    registry: "docker.io"
    repository: "amazon/aws-cli"
    tag: "latest"
    pullPolicy: Always
  azureImage:
    registry: "mcr.microsoft.com"
    repository: "azure-cli"
    tag: "latest"
    pullPolicy: Always

## Flyawy image is used to apply database migrations
##
flywayImage:
  registry: "docker.io"
  repository: flyway/flyway
  tag: "10-alpine"
  pullPolicy: Always

imagePullSecrets: []

## Provide a name in place of operator for `app:` labels
##
nameOverride: ""

## Provide a name to substitute for the full names of resources
##
fullnameOverride: ""

## Web3Signer Settings
## ref: https://docs.web3signer.consensys.net/en/latest/Reference/CLI/CLI-Syntax/
##

## Network
## Options: mainnet, prater, gnosis
network: "mainnet"

## Sets logging verbosity.
## Log levels are OFF, FATAL, WARN, INFO, DEBUG, TRACE, ALL.
loggingLevel: "INFO"

## Number of epochs to keep when pruning the slashing protection database.
##
pruningEpochToKeep: 100

## Hours between slashing protection database pruning operations.
##
pruningInterval: 24

## Number of slots per epoch. This number multiplied by the number of epochs to keep determines what blocks to keep when pruning the slashing protection database.
## The default is 32 as defined on MainNet/Prater.
##
slotsPerEpoch: 32

## The Java Database Connectivity (JDBC) URL of the slashing protection database.
##
dbUrl: "jdbc:postgresql://localhost/web3signer"

## The username to use when connecting to the slashing protection database.
##
dbUsername: ""

## The password to connect to the slashing protection database.
## Use dbPassword for plain text (not recommended) or existingSecrets for production.
##
dbPassword: ""

## Use existing Kubernetes secrets instead of passing values directly.
## This is the recommended approach for production deployments.
## When set, the corresponding plain text values above are ignored.
##
existingSecrets:
  ## Database password secret
  dbPassword:
    ## Name of existing secret containing the database password
    name: ""
    ## Key within the secret
    key: "password"
  ## Decryption key secret (for decrypting validator keys from keystore DB)
  decryptionKey:
    ## Name of existing secret containing the decryption key
    name: ""
    ## Key within the secret
    key: "decryptionKey"
  ## Keystore database URL secret (postgresql://user:pass@host/db format)
  dbKeystoreUrl:
    ## Name of existing secret containing the full keystore DB URL
    name: ""
    ## Key within the secret
    key: "dbKeystoreUrl"

## Port on which Web3Signer HTTP listens.
##
httpPort: 6174

## The port (TCP) on which Prometheus accesses metrics
##
metricsPort: 9000

## Java Opts
##
web3signerJavaOpts: "-Xmx1g -Xms1g"

## Enables the key manager API.
##
keyManagerApiEnabled: "false"

## Override the container command (if specified, overrides Docker ENTRYPOINT)
## Leave empty to use the default Docker ENTRYPOINT: ["/opt/web3signer/bin/web3signer"]
##
command: []

## Override the container args (if specified, overrides the default args)
##
args:
  - --config-file=/config/config.yaml
  - eth2
  - --slashing-protection-pruning-at-boot-enabled=true

## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
##
serviceAccount:
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

## Pod labels to add
podLabels: {}

## Pod Security Context
## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
##
podSecurityContext:
  fsGroup: 1000
  runAsUser: 1000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  type: ClusterIP
  port: 80

## Configure resource requests and limits.
## ref: http://kubernetes.io/docs/user-guide/compute-resources/
##
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

## Node labels for pod assignment
## ref: https://kubernetes.io/docs/user-guide/node-selection/
##
nodeSelector: {}

## Tolerations for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
##
tolerations: {}

## Affinity for pod assignment
## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
##
affinity: {}

## Prometheus Service Monitor
## ref: https://github.com/coreos/prometheus-operator
##      https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
##
serviceMonitor:
  ## @param metrics.serviceMonitor.enabled Create ServiceMonitor resource(s) for scraping metrics using PrometheusOperator
  ##
  enabled: false
  ## @param metrics.serviceMonitor.namespace The namespace in which the ServiceMonitor will be created
  ##
  namespace: ""
  ## @param metrics.serviceMonitor.interval The interval at which metrics should be scraped
  ##
  interval: 30s
  ## @param metrics.serviceMonitor.scrapeTimeout The timeout after which the scrape is ended
  ##
  scrapeTimeout: ""
  ## @param metrics.serviceMonitor.relabellings Metrics RelabelConfigs to apply to samples before scraping.
  ##
  relabellings: []
  ## @param metrics.serviceMonitor.metricRelabelings Metrics RelabelConfigs to apply to samples before ingestion.
  ##
  metricRelabelings: []
  ## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
  ##
  honorLabels: false
  ## @param metrics.serviceMonitor.additionalLabels Additional labels that can be used so ServiceMonitor resource(s) can be discovered by Prometheus
  ##
  additionalLabels: {}

## Ingress configuration
## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
##
ingress:
  ## Enable ingress resource
  enabled: false

  ## Ingress class name (e.g., "nginx", "azure-application-gateway")
  className: "nginx"

  ## Additional annotations for the ingress resource
  annotations: {}

  ## Request timeout in seconds (for NGINX ingress)
  requestTimeout: "60"

  ## Ingress hosts configuration
  hosts:
    - host: web3signer.internal
      paths:
        - path: /
          pathType: Prefix

  ## TLS configuration for HTTPS
  ## Each entry should have hosts (list) and secretName
  tls: []
  # - hosts:
  #     - web3signer.internal
  #   secretName: web3signer-server-tls

  ## mTLS configuration for client certificate verification
  ## Only supported with NGINX ingress controller
  mtls:
    ## Enable mTLS client certificate verification
    enabled: false

    ## CA secret for verifying client certificates
    ## Format: "namespace/secret-name"
    caSecret: "cert-manager/mtls-ca-secret"

    ## Client verification mode:
    ## - "on": require valid client certificate
    ## - "optional": request but don't require client certificate
    ## - "optional_no_ca": request certificate but don't verify against CA
    verifyClient: "on"

    ## Certificate chain verification depth
    verifyDepth: "1"

## Certificate configuration (requires cert-manager)
## Creates a Certificate resource for server TLS
##
certificate:
  ## Enable automatic certificate generation via cert-manager
  enabled: false

  ## Name of the Kubernetes secret to store the certificate
  secretName: "web3signer-server-tls"

  ## Certificate duration (default: 1 year)
  duration: "8760h"

  ## Time before expiry to renew (default: 30 days)
  renewBefore: "720h"

  ## Organization name in the certificate subject
  organization: "Galaxy"

  ## DNS names to include in the certificate
  ## If empty, defaults to service name variants
  dnsNames: []
  # - web3signer.internal.example.com

  ## Private key configuration
  privateKey:
    algorithm: "ECDSA"
    size: 256

  ## Reference to the cert-manager issuer
  issuerRef:
    name: "mtls-ca-issuer"
    kind: "ClusterIssuer"

# A Note about Init Containers:
# The init containers are used to prepare the environment before the main web3signer container starts.
# The default init containers handle common tasks such as initializing data directories, fetching keys from a database, copying migration files, and running database migrations.
#
# Users can easily modify the existing init containers or add new ones as needed by editing the values.yaml file.
# However, if you need to make a change to this list, you MUST include _every_ init container you want to run, as this list
# completely replaces the default list.
#
# Some values in the init containers can be templated using Helm templating.
# See the _helpers.tpl, `web3signer.initContainer` template and look for `tpl`
# to know which fields support templating.
#
# Special field: usesDecryptedSecret
# When encryptedDecryptionKey.enabled=true, containers with usesDecryptedSecret=true will:
#   1. Have their command/args wrapped to source DECRYPTION_KEY from /decrypted-secrets/DECRYPTION_KEY
#   2. Automatically mount the decrypted-secrets volume
#   3. Skip the envFrom (since the key comes from file instead)
# This allows containers like fetch-keys to transparently work with both plain text and encrypted modes.

initContainers:
  # Initialize data directories and set proper ownership
  - name: init
    image:
      registry: "docker.io"
      repository: busybox
      tag: "stable"
      pullPolicy: Always
    securityContext:
      runAsUser: 0
    command:
      - sh
      - -ac
      - >
        mkdir -p /data/web3signer /data/keystore;
        chown -R 1000:1000 /data/web3signer /data/keystore
    volumeMounts:
      - name: data
        mountPath: /data

  # Fetch validator keys from database
  # When encryptedDecryptionKey.enabled=true, this container will:
  #   - Use a shell wrapper to source DECRYPTION_KEY from /decrypted-secrets/DECRYPTION_KEY
  #   - Mount the decrypted-secrets volume (automatically added by the template)
  # When encryptedDecryptionKey.enabled=false (default):
  #   - Uses DECRYPTION_KEY from the secret via envFrom (legacy behavior)
  - name: fetch-keys
    # Mark this container as needing the decrypted secret
    usesDecryptedSecret: true
    image:
      registry: "ghcr.io"
      repository: "galaxydigitalpublic/sync-keys"
      tag: "0.4.0"
      pullPolicy: Always
    # Uses pod's default securityContext (runAsUser: 1000)
    workingDir: /src
    command:
      - python
      - ./main.py
    args:
      - sync-web3signer-keys
      - --db-url
      - '{{ .Values.dbKeystoreUrl }}'
      - --output-dir
      - /data/keystore
    envFrom:
      - secretRef:
          name: '{{ include "common.names.fullname" . }}'
    volumeMounts:
      - name: data
        mountPath: /data

  # Copy database migration files
  - name: copy-migrations
    # Uses main container image by default (no image config specified)
    command:
      - sh
      - -ac
      - cp -v /opt/web3signer/migrations/postgresql/* /migrations/
    volumeMounts:
      - name: migrations
        mountPath: /migrations

  # Run database migrations
  - name: migrations
    image:
      registry: "docker.io"
      repository: flyway/flyway
      tag: "10-alpine"
      pullPolicy: Always
    securityContext:
      runAsUser: 0
    args:
      - '-user={{ .Values.dbUsername }}'
      - '-password={{ .Values.dbPassword }}'
      - '-url={{ .Values.dbUrl }}'
      - '-locations=filesystem:/migrations'
      - 'migrate'
    volumeMounts:
      - name: migrations
        mountPath: /migrations
